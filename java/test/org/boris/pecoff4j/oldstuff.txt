private static void readImageDataPreSections(PE pe, IDataReader dr)
            throws IOException {
        // Check for bound imports
        ImageData id = new ImageData();
        pe.setImageData(id);
        ImageDataDirectory bi = pe.getOptionalHeader().getDataDirectory(
                ImageDataDirectoryType.BOUND_IMPORT);
        if (bi.getSize() > 0) {
            // Need to read the bound imports directly
            dr.jumpTo(bi.getVirtualAddress());
            byte[] bib = new byte[bi.getSize()];
            dr.read(bib);
            IDataReader bidr = new ByteArrayDataReader(bib);
            id.setBoundImports(readBoundImportDirectoryTable(bidr));
        }

        // Now read in padding data (which may have some stuff)
        SectionTable st = pe.getSectionTable();
        SectionHeader[] sorted = st.getHeadersPointerSorted();
        SectionHeader sh1 = null;
        for (int i = 0; i < sorted.length; i++) {
            sh1 = sorted[i];
            if (sh1.getVirtualSize() > 0)
                break;
        }
        int pr = sh1.getPointerToRawData();
        int pc = dr.getPosition();
        if (pr > pc) {
            byte[] padding = new byte[pr - pc];
            dr.read(padding);
            id.setHeaderPadding(padding);
        }
    }

    private static void readSections(PE pe, IDataReader dr) throws IOException {
        SectionTable st = pe.getSectionTable();
        SectionHeader[] headers = st.getHeadersPointerSorted();

        for (SectionHeader sh : headers) {
            if (sh.getPointerToRawData() > 0 && sh.getVirtualSize() > 0) {
                dr.jumpTo(sh.getPointerToRawData());
                byte[] data = new byte[sh.getSizeOfRawData()];
                dr.read(data);
                SectionData sd = new SectionData();
                sd.add(data);
                st.add(sd);
            } else {
                st.add(new SectionData());
            }
        }

    }

    private static void readImageDataPostSections(PE pe, IDataReader dr)
            throws IOException {
        ImageData id = pe.getImageData();

        int firstSectionAddress = 0;
        int lastSectionExtent = 0;
        SectionHeader[] headers = pe.getSectionTable()
                .getHeadersPointerSorted();
        for (int i = 0; i < headers.length; i++) {
            SectionHeader sh = headers[i];
            if (firstSectionAddress == 0 && sh.getVirtualSize() > 0 &&
                    sh.getPointerToRawData() > 0) {
                firstSectionAddress = sh.getPointerToRawData();
            }

            if (sh.getVirtualSize() > 0) {
                lastSectionExtent = sh.getPointerToRawData() +
                        sh.getVirtualSize();
            }
        }

        // Check for debug section
        ImageDataDirectory ddd = pe.getOptionalHeader().getDataDirectory(
                ImageDataDirectoryType.DEBUG);
        if (ddd.getSize() > 0) {
        }

        ImageDataDirectory cdd = pe.getOptionalHeader().getDataDirectory(
                ImageDataDirectoryType.CERTIFICATE_TABLE);
        if (cdd.getSize() > 0) {
            if (cdd.getVirtualAddress() >= lastSectionExtent) {
                dr.jumpTo(cdd.getVirtualAddress());
                byte[] cb = new byte[cdd.getSize()];
                dr.read(cb);
                id.setCertificateTable(cb);
            }
        }
    }
    
    public static void parse(PE pe) throws IOException {
        readExportTable(pe);
        readImportTable(pe);
        readResourceTable(pe);
    }

    private static void readResourceTable(PE pe) throws IOException {
        OptionalHeader oh = pe.getOptionalHeader();
        SectionTable st = pe.getSectionTable();
        ImageDataDirectory idd = oh
                .getDataDirectory(ImageDataDirectoryType.IMPORT_TABLE);
        SectionHeader sh = st.findHeader(SectionTable.IMPORT_TABLE);
        SectionData sd = st.findSection(SectionTable.IMPORT_TABLE);
        if (idd.getVirtualAddress() != sh.getVirtualAddress())
            return;
        if (idd.getSize() != sh.getVirtualSize())
            return;
        byte[] b = (byte[]) sd.getEntry(0).getValue();
        ImportDirectory id = PEParser.readImportDirectory(
                new ByteArrayDataReader(b), idd.getVirtualAddress());
        sd.clear();
        sd.add(ImageDataDirectoryType.IMPORT_TABLE, id);
    }

    private static void readImportTable(PE pe) throws IOException {
        OptionalHeader oh = pe.getOptionalHeader();
        SectionTable st = pe.getSectionTable();
        ImageDataDirectory idd = oh
                .getDataDirectory(ImageDataDirectoryType.RESOURCE_TABLE);
        SectionHeader sh = st.findHeader(SectionTable.RESOURCE_TABLE);
        SectionData sd = st.findSection(SectionTable.RESOURCE_TABLE);
        if (idd.getVirtualAddress() != sh.getVirtualAddress())
            return;
        if (idd.getSize() != sh.getVirtualSize())
            return;
        byte[] b = (byte[]) sd.getEntry(0).getValue();
        ResourceDirectory id = PEParser.readResourceDirectory(b, idd
                .getVirtualAddress());
        sd.clear();
        sd.add(ImageDataDirectoryType.RESOURCE_TABLE, id);
    }

    private static void readExportTable(PE pe) throws IOException {
        OptionalHeader oh = pe.getOptionalHeader();
        SectionTable st = pe.getSectionTable();
        ImageDataDirectory idd = oh.getExportTable();
        SectionHeader sh = st.findHeader(SectionTable.EXPORT_TABLE);
        SectionData sd = st.findSection(SectionTable.EXPORT_TABLE);
        if (idd.getVirtualAddress() != sh.getVirtualAddress())
            return;
        if (idd.getSize() != sh.getVirtualSize())
            return;
        byte[] b = (byte[]) sd.getEntry(0).getValue();
        ExportDirectoryTable id = PEParser
                .readExportDirectoryTable(new ByteArrayDataReader(b));
        sd.clear();
        sd.add(ImageDataDirectoryType.EXPORT_TABLE, id);
    }
    
        private static void writeSections(PE pe, IDataWriter dw) throws IOException {
        SectionTable st = pe.getSectionTable();
        SectionHeader[] headers = st.getHeadersPointerSorted();

        for (int i = 0; i < headers.length; i++) {
            SectionHeader sh = headers[i];
            int pr = sh.getPointerToRawData();
            int pc = dw.getPosition();
            if (pr > pc) {
                dw.writeByte(0, pr - pc);
            }
            SectionData sd = st.getSection(i);
            if (sd != null && sd.size() > 0) {
                byte[] b = (byte[]) sd.getEntry(0).getValue();
                dw.writeBytes(b);
            }
        }
    }
    